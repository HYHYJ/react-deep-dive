# 2장 리액트 핵심 요소 깊게 살펴보기

- [2장 리액트 핵심 요소 깊게 살펴보기](#2장-리액트-핵심-요소-깊게-살펴보기)
- [2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션](#25-컴포넌트와-함수의-무거운-연산을-기억해-두는-메모이제이션)
  - [2.5.1 주장 1](#251-주장-1)
  - [2.5.2 주장 2](#252-주장-2)
  - [2.5.3 정리](#253-정리)

# 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션
 * 리액트에서는 제공하는 API 중 `useMemo` , `useCallback`, `React.memo`는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해 제공된다. 모두 최적화 기법에 사용된다는 것은 알지만 언제 사용하는지에 대해서는 답변하기가 어렵다.

## 2.5.1 주장 1
> 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자

```
function sum(a, b){
  return a + b
}
```
❓간단한 연산을 수행하는 함수를 메모이제이션해두는게 좋을까요? 아니면 매번 새로운 계산을 하는게 좋을까요?
-> 매번 작업을 수행해 결과를 반환하는 것이 더 빠를 수 있다.

🤔 리액트와 자바스크립트 입장에서 생각해보자
* 메모이제이션은 모든 것을 해결할 수 있는 마법과 같은 것 X. 메모이제이션에도 비용이 든다.
* 값을 비교하고 렌더링 또는 재계산이 필요한지 <u>확인하는 작업</u>, 그리고 이전에 결과물을 저장해 두었다가 <u>다시 꺼내와야 하는 작업</u>, 두 가지 비용이 있다.
-> 리렌더링 비용보다 저렴하다고 할 수 있을까?

> 💡 <b>항상 메모이제이션은 신중하게 접근해야하며 섣부른 최적화는 항상 경계해야 한다.</b>

* 이러한 비교와 렌더링이 문제가 됐다면 리액트에서는 진작에 모든 컴포넌트를 `PureComponent`로 만들었거나 `React.memo`로 감싸두는 작업을 했을 것이다. 그렇지 않고 이를 개발자에게 선택권을 넘겼다는 것은 메모이제이션이 모든 문제를 해결할 수 있는 silver bullet 이 아니라는 사실을 반증한다.

```
아무데서나 PureComponent를 쓰지 마세요.
왜 모든 컴포넌트에 memo()를 기본값으로 사용하지 않나요?
그게 더 빠르지 않나요? 스스로에게 물어보세요.
왜 lodash의 모든 함수에 memoize()를 사용하지 않나요?
그게더 빠르지 않나요? 혹시 벤치마크로 성능을 확인해봐야 하지 않을까요?
```
출처: 리액트 개발자. 댄 아브라모프 트위터

* 따라서 메모이제이션은 항상 어느정도 트레이드 오프가 있는 기법이라고 보는 것이 옳다.
* 렌더링도 비용이지만 메모리에 저장하는 것도 마찬가지로 비용입니다. 메모이제이션으로 인한 성능 개선이 렌더링보다 낫지 않다면 결국 안하느니만 못하는 상황을 마주하게 되는 것이다.

```
useMemo는 성능 최적화를 위해 사용할 수는 있지만
의미상으로 보장이 있다고 생각하지는 마세요.
가까운 미래에 React에서는, 이전 메모이제이션된 값들의 일부를 “잊어버리고”
다음 렌더링 시에 그것들을 재계산하는 방향을 택할지도 모르겠습니다.
예를 들면, 오프스크린 컴포넌트의 메모리를 해제하는 등이 있을 수 있습니다.
useMemo를 사용하지 않고도 동작할 수 있도록 코드를 작성하고
그것을 추가하여 성능을 최적화하세요. 
```
[출처: 리액트 홈페이지](https://ko.legacy.reactjs.org/docs/hooks-reference.html#usememo)

* 리액트에서는 가능한 한 오랫동안 이 캐시 결과를 저장하려고는 하겠지만 미래의 어떤 경우에 따라서는 캐시가 무효화되는 경우도 있을 것이다. 이 문서에서 이야기하고 있는 것처럼 리액트가 `useMemo` 를 언제까지고 성능 최적화를 위해 제공해줄 것이라는 보장이 없다. 따라서 섣불리 최적화하는 것은 옳지 못하다.
-> 그러므로 리액트에서는 메모이제이션을 활용한 최적화는 신중을 기해야 한다.

> 💡 일단 애플리케이션을 어느정도 만든 이후에 개발자 도구나 `useEffect`를 사용해 실제로 어떻게 렌더링이 일어나고 있는지 확인하고 필요한 곳에만 최적화 하는 것이 옳다.


## 2.5.2 주장 2
> 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해버리자.

주장 1과 주장 2에서 공통으로 깔고가는 전제는 다음과 같다.
-> 일부 컴포넌트에서는 메모이제이션을 하는 것이 성능에 도움이 된다. 섣부른 최적화인지 여부와는 관계없이, 만약 해당 컴포넌트가 렌더링이 자주 일어나며 그 렌더링 사이에 비싼 연산이 포함돼 있고, 심지어 그 컴포넌트가 자식 컴포넌트 또한 많이 가지고 있다면 `React.memo`나 다른 메모이제이션 방법을 사용하는 것이 이점이 있을 때가 분명히 있다.

> 1. React.memo 를 컴포넌트의 사용에 따라 잘 살펴보고 일부에만 적용하는 방법
> 2. React.memo를 일단 그냥 다 적용하는 방법

첫번째 경우는 주장 1에서 살펴봤던 것처럼 가장 이상적인 상황이다.

🤔그러나 애플리케이션의 규모가 커지고 개발자가 많아지고 컴포넌트가 복잡한 상황에서 필요한 상황을 찾고 생각하는게 쉬울까요?
-> X 

* 잘못된 `memo`로 지불해야 하는 비용은 바로 `props`에 대한 얕은 비교(객체나 배열의 참조)가 발생하면서 지불해야하는 비용이다.
* 메모이제이션을 위해서는 CPU와 메모리를 사용해 이전 렌더링 결과물을 저장해 둬야하고, 리렌더링할 필요가 없다면 이전 결과물을 사용해야한다.

`memo`를 하지 않았을 때 발생할 수 있는 문제
> 렌더링을 함으로써 발생하는 비용
> 컴포넌트 내부의 복잡한 로직의 재실행
> 그리고 위 두가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
> 리액트가 구 트리와 신규 트리를 비교

-> `memo`를 하지 않았을 때 치러야할 잠재적인 위험 비용이 더 크다는 사실

> 💡 메모이제이션은 하지 않는 것보다 메모이제이션했을 때 더 많은 이점을 누릴 수 있다. 이것이 비록 섣부른 초기화라 할지라도 했을 때 누릴 수 있는 이점, 그리고 이를 실수로 빠뜨,렸을 때 치러야할 위험 비용이 더 크기 때문에 최적화에 대한 확신이 없다면 가능한 한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.


## 2.5.3 정리

두 의견 모두 메모이제이션이 리액트 애플리케이션에서 할 수 있는 성능 최적화라는 사실에 대해서는 이견이 없다. 다만 이를 어떤 식으로 얼마나 적용할 것인지에 대한 의견의 차이는 있다. 과연 무엇이 정답일까?

1️⃣ 리액트를 배우고 있거나 혹은 리액트를 깊이 이해하고 싶고, 이를 위해 시간을 투자할 여유가 있다면 주장1의 의견대로 섣부른 메모이제이션을 지양하는 자세를 견지하면서 실제 어느 지점에서 성능상 이점을 누릴 수 있는지 살펴보는 식으로 메모이제이션을 적용하는 것을 권장

2️⃣ 현업에서 리액트를 사용하고 있거나 실제로 다룰 예정이지만 성능에 대해 깊게 연구해 볼 시간적 여유가 없는 상황이라면 일단 의심스러운 곳에는 먼저 다 적용해 볼 것을 권장