# 3장 리액트 훅 깊게 살펴보기

- [3장 리액트 훅 깊게 살펴보기](#3장-리액트-훅-깊게-살펴보기)
- [3.1 리액트의 모든 훅 파헤치기](#31-리액트의-모든-훅-파헤치기)
  - [3.1.3 useMemo](#313-usememo)
  - [3.1.4 useCallback](#314-usecallback)
    - [📌usecallback : 인수로 넘겨받은 콜백 자체를 기억](#usecallback--인수로-넘겨받은-콜백-자체를-기억)
    - [📌\[useMemo 🤜VS🤛 usecallback 차이점\]](#usememo-vs-usecallback-차이점)
    - [📌usecallback((함수),(의존성 배열),)](#usecallback함수의존성-배열)
    - [왜 usecallback에 기명 함수를 넘겨주었나요?](#왜-usecallback에-기명-함수를-넘겨주었나요)
  - [3.1.5 useRef](#315-useref)

# 3.1 리액트의 모든 훅 파헤치기

## 3.1.3 useMemo

## 3.1.4 useCallback

#### 📌usecallback : 인수로 넘겨받은 콜백 자체를 기억

💁‍♀️**특정 함수**를 새로 만들지 않고✖️, 다시 재사용🔁

- \*usememo: 값 기억.

[코드 3.18] `memo`를 사용함 ➡️ **BUT.** **전체** 자식 컴포넌트가 **리렌더링**되는 예제🤔

```js

//켜짐 꺼짐 토글 버튼 컴포넌트
const Childcomponent = memo(({ name, value, onchange }) => {

return{
    <>
      <h1>
      {name} {value ?'켜짐' :'꺼짐'}
      </h1>

      <button onClick={onchange}>toggle</button>
    </>
  )
});

//컴포넌트 사용
function App() {
const [status1, setstatus1] = usestate(false)
const [status2, setstatus2] = usestate(false)

const toggle1 = () ={
    settatus1(!status1)
}
const toggle2 = () ={
    settatus1(!status2)
}

return{
  <>
    <ChildComponent name="1" value={status1} onChange={toggle1} />
    <ChildComponent name="2" value={status2} onchange-{toggle2} />
  </>
  )
}
```

🤔**memo**를 사용해서 컴포년트를 메모이제이션했지만 App의 **자식 컴포년트 전체가 렌더링**되고 있다.

1. 위 코드는 memo를 사용해 name, value, onchange의 값을 모두 기억
2. 값이 변경되지 않았을 때는 렌더링되지 않도록 작성된 코드
3. 하나의 value 변경이 다른 컴포넌트에 영향을 미쳐서는 안됨 ➡️ 영향미치는 중..
4. 클릭할 때마다 하나의 컴포년트만 렌더링되야함.
   🥲**BUT.** 한 버튼을 클릭하면 클릭하지 않은 컴포년트도 렌더링

➡️ 이유는 state 값이 바뀌면서 App 컴포년트가 리렌더링되고, 그때마다 매번 onchange로 넘기는 함수가 재생성되고 있기 때문이다.
<br/>

#### 📌[useMemo 🤜VS🤛 usecallback 차이점]

> **useMemo:** **값**의 메모이제이션
> **usecallback :** **함수**의 메모이제이션

<br/>

#### 📌usecallback((함수),(의존성 배열),)

usecallback의 첫 번째 인수로 함수를, 두 번째 인수로 의존성 배열을 집어 넣으면 **의존성 배열이 변경되지 않는 한 함수를 재생성✖️**

[코드 3.19] 이전 예제의 컴포넌트에 usecalback만 추가한 코드

```js
const ChildComponent = memo(({ name, value, onchange }) => {

return(
  <>
    <h1>
      {name} {value ? '켜짐' : '꺼짐'}
    </h1>
    <button onclick=fonChangel>toggle</button>
  </>
  )
})

function App() {
const [status1, setstatus1] = useState(false)
const [status2, setStatus2] = usestate(false)
const togglel = useCallback(

function toggle() {
  setStatus1(!statusl)
  },
  [status1],
}
const toggle2 = useCallback(
  function toggle2() {
    setStatus2(!status2)
  },
 [status2],
}
  return {
    <>
      <ChildComponent name="1" value={status1} onChange={toggle1} />
      <ChildComponent name="2" value={status2} onChange={toggle2}/>
    </>
    )
  }
```

usecallback을 추가하면 해당 의존성이 변경됐을 때만 함수가 재생성되는 것을 볼 수 있다.
이처럼 함수의 재생성을 막아 불필요한 리소스 또는 리렌더링을 방지하고 싶을 때 usecallback을 사용해 볼 수 있다

#### 왜 usecallback에 기명 함수를 넘겨주었나요?

일반적으로 usecallback이|나 useMeno를 사용할 때 useEffect와 마찬가지로 많은 코드가 익명 함수로 첫 번째
인수를 넘겨
준다.

```js
const togglel = useCallback(() =>{
  setstatus1(!status1)
, [status1])

```

그러나 위 예제에서는 기명 함수를 넘겨줬는데. 이는 크롬 메모리 탭에서 디버깅을 용이하게 하기 위함이다. 익명 함수는 말 그대
로 이름이 없어 해당 함수를 추적하기 어렵기 때문이다. 기명 함수로 선언한 함수를 크롬 개발자 도구에서 디버강하는 방법은 7장
크롬 개발자 도구를 활용한 애플리케이션 분석'에서 다룬다.

기본적으로 useCallback은 useMemo를 사용해서 구현할 수 있다.

[코드 3.20] Preact에서의 useCallback 구현

```js
export function usecallback(callback, args) {
  currentHook = 8;
  return useMemo(() => callback, args);
}
```

🥲useMemo로 useCallback을 구현하는 경우, 불필요하게 코드가 매우 길어지고 혼동을 야기 할 수 있음.

➡️리액트에서 별도로 제공하는 것으로 추측해 볼수있다.

```js
export default function App() {
const [counter, setCounter] = usestate(0)

//아래 두함수의 작동은 동일하다.
//1. useCallback
const handleClick1 = useCallback(() =>{
setCounter((prev) => prev + 1)
},[])

//2. useMemo로 useCallback 구현
const handleclick2 = useMemo(() => {
retur () => setCounter((prev) => prev + 1)
},[])

```

useMemo는 값 자체를 메모이제이션하는 용도 ➡️ 반환문으로 함수를 반환
<br/>
➡️🥲코드 작성, 리뷰 혼란을 불러올 수 있으므로 **함수를 메모이제이션하는 용도라면 usecallback을 사용**🤛

📌다만 기억해야 할 사실은 **usecallback이나 useMemo는 모두 동일
한 역할**올 한다는 것이다.

## 3.1.5 useRef
