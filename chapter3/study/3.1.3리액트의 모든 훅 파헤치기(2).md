# 3장 리액트 훅 깊게 살펴보기

- [3장 리액트 훅 깊게 살펴보기](#3장-리액트-훅-깊게-살펴보기)
- [3.1 리액트의 모든 훅 파헤치기](#31-리액트의-모든-훅-파헤치기)
  - [3.1.3 useMemo](#313-usememo)
  - [3.1.4 useCallback](#314-usecallback)
    - [📌usecallback : 인수로 넘겨받은 콜백 자체를 기억](#usecallback--인수로-넘겨받은-콜백-자체를-기억)
    - [📌\[useMemo 🤜VS🤛 usecallback 차이점\]](#usememo-vs-usecallback-차이점)
    - [📌usecallback((함수),(의존성 배열),)](#usecallback함수의존성-배열)
  - [3.1.5 useRef](#315-useref)

# 3.1 리액트의 모든 훅 파헤치기

## 3.1.3 useMemo

## 3.1.4 useCallback

#### 📌usecallback : 인수로 넘겨받은 콜백 자체를 기억

💁‍♀️**특정 함수**를 새로 만들지 않고✖️, 다시 재사용🔁

- \*usememo: 값 기억.

[코드 3.18] `memo`를 사용함 ➡️ **BUT.** **전체** 자식 컴포넌트가 **리렌더링**되는 예제🤔

```js

//켜짐 꺼짐 토글 버튼 컴포넌트
const Childcomponent = memo(({ name, value, onchange }) => {

return{
    <>
      <h1>
      {name} {value ?'켜짐' :'꺼짐'}
      </h1>

      <button onClick={onchange}>toggle</button>
    </>
  )
});

//컴포넌트 사용
function App() {
const [status1, setstatus1] = usestate(false)
const [status2, setstatus2] = usestate(false)

const toggle1 = () ={
    settatus1(!status1)
}
const toggle2 = () ={
    settatus1(!status2)
}

return{
  <>
    <ChildComponent name="1" value={status1} onChange={toggle1} />
    <ChildComponent name="2" value={status2} onchange-{toggle2} />
  </>
  )
}
```

🤔**memo**를 사용해서 컴포년트를 메모이제이션했지만 App의 **자식 컴포년트 전체가 렌더링**되고 있다.

1. 위 코드는 memo를 사용해 name, value, onchange의 값을 모두 기억
2. 값이 변경되지 않았을 때는 렌더링되지 않도록 작성된 코드
3. 하나의 value 변경이 다른 컴포넌트에 영향을 미쳐서는 안됨 ➡️ 영향미치는 중..
4. 클릭할 때마다 하나의 컴포년트만 렌더링되야함.
   🥲**BUT.** 한 버튼을 클릭하면 클릭하지 않은 컴포년트도 렌더링

➡️ 이유는 state 값이 바뀌면서 App 컴포년트가 리렌더링되고, 그때마다 매번 onchange로 넘기는 함수가 재생성되고 있기 때문이다.
<br/>

#### 📌[useMemo 🤜VS🤛 usecallback 차이점]

> **useMemo:** **값**의 메모이제이션
> **usecallback :** **함수**의 메모이제이션

<br/>

#### 📌usecallback((함수),(의존성 배열),)

usecallback의 첫 번째 인수로 함수를, 두 번째 인수로 의존성 배열을 집어 넣으면 **의존성 배열이 변경되지 않는 한 함수를 재생성✖️**

<!-- (코드 3.19] 이전 예제의 컴포넌트에 usecalback만 추가한 코드
const ChildComponent = memo(( name, value, onchange ) =>t
useEffect(() => t
console. log('rendering! ', name)
A
return
C
<l>
(name] [value ? '켜짐' : '꺼짐'

</h1>
<button onclick=fonChangel>toggle</button>
스>
P
function App() t
const [status1, setstatus1] = useState(false)
const [status2, setStatus2] = usestate(false)
const togglel = useCallback(

function toggle10 t
setStatus1(!statusl)
~
[status1],
const toggle2 11
useCallback(
function toggle2() (
setStatus2('status2)

- [status2],
  REX
  return
  C
  D
  <ChildComponent name="1" value=(status1] onChange=(toggle1] />
  <ChildComponent name="2" value=(status2> onChange=(toggle2]\_/>
  Jack
  </>

usecallback을 추가하면 해당 의존성이 변경됐을 때만 함수가 재생성되는 것을 볼 수 있다.
이처럼 함수의
재생성을 막아 남펄요한 리소스 또는 리렌터링을 방지하고 싶을 때 usecallback을 사용해 볼 수 있다
왜 usecallback에 기명 함수를 넘겨주었나요?
일반적으로 usecallback이|나 useMeno를 사용할 때 useEffect와 마찬가지로 많은 코드가 익명 함수로 첫 번째
인수를 넘겨
준다.
const togglel = useCallback(() =>t
setstatus1(!status1)
, [status1])
그러나 위 예제에서는 기명 함수를 넘겨줬는데. 이는 크롬 메모리 탭에서 디버깅을 용이하게 하기 위함이다. 익명 함수는 말 그대
로 이름이 없어 해당 함수를 추적하기 어렵기 때문이다. 기명 함수로 선언한 함수를 크롬 개발자 도구에서 디버강하는 방법은 7장
크롬 개발자 도구를 활용한 애플리케이션 분석'에서 다룬다.
기본적으로 usecallback은 usewemo를 사용해서 구현할 수 있다. 이는 Preact에서도 리액트 공식 문서에서도
확인해 볼 수 있는사실이다.3
(코드 3.20] Preact에서의 useCallback 구현
export function usecallback(callback, args) t
currentHook = 8
return useMemo(() => callback, args)

usewemo와 usecallback의 유일한 차이는 메모이제이션을 하는 대상이 번수냐 합수나일 쁜이다. 자바스크립
로 트에서는 useCallback을 합수 또한 구현하는 값으로 표현될 경우다음과 수 있으므로 같이 이러한 불필요하게 코드는 코드가 매우 길어지고 자언스럽다고 혼동을 볼 수 야기할수 있다. 다만 있으므로 uSeMemo 리액
트에서 별도로 제공하는 것으로 추측해 볼수있다.
import f usestate, useCallback, useMemo t from 'react'
export default function App() t
const [counter, setCounter] = usestate(0)
.수 있다. 이지집
용해 볼 수있다,.
/
아래 두함수의 작동은 동일하다.
const handleClick1 = usecallback(() =>[
setCounter((prev) => prev + 1)
로 첫 번째 인수금병
const handleclick2 = useMemo(() => t
retur () => setCounter((prev) => prev + 1)
D)
과
return C
D
<h >fcounter]</h1>
<button onClick=thandleClick13>+</button>
<button onClick=(handleclick2]>+</button>
입명 함수는 말교
1강하는 방법은
식 문서에
예제에서 usecallback을 사용한 handleclick1이|나 usetemo를 사용한 handleClick2 모두 동일한 기능을 가
진다. 다만 useMemo는 값 자체를 메모이제이션하는 용도이기 때문에 반환문으로 함수 선언문을 반환해야 한
다. 이는 코드를 작성하거나 리뷰하는 입장에서 혼란을 불러올 수 있으므로 함수를 메모이제이션하는 용도라
면 좀 더 간판한 usecallback을 사용하자. 다만 기억해야 할 사실은 usecallback이나 useMemo는 모두 동일
한역할올 한다는 것이다. -->

## 3.1.5 useRef
